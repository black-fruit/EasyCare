interface IRetryPromiseOption {
  timeout?: number;
  retryTime?: number;
  interval?: number;
}

const TIMEOUT_ERROR_MSG = 'time out';

const createTimeoutPromise = <T>(timeout: number, isResolve: boolean): Promise<T> => {
  const timeoutPromise = new Promise<T>((resolve, reject) => {
    setTimeout(() => {
      if(isResolve) {
        resolve();
      } else {
        reject(TIMEOUT_ERROR_MSG);
      }
    }, timeout);
  });
  return timeoutPromise;
}

function retryPromise <TParam, UReturn = any>(originRequestFunc: (arg?: TParam) => Promise<UReturn>, option?: IRetryPromiseOption) {
  let retryTime = 5;
  let interval = 1000;
  let timeout = 3000;
  let hasRetryTime = 0;
  if(option) {
    if(option.interval) {
      interval = option.interval;
    }
    if(option.retryTime) {
      retryTime = option.retryTime;
    }
    if(option.timeout) {
      timeout = option.timeout;
    }
  }

  const retryFunc = async (arg?: TParam): Promise<UReturn> => {

    const timeoutPromise = createTimeoutPromise<UReturn>(timeout, false);

    try {

      return await Promise.race<UReturn>([
        timeoutPromise,
        originRequestFunc(arg),
      ]);
      
    } catch (err) {
      if(hasRetryTime < retryTime) {
        const nextTimeoutPromise = createTimeoutPromise<UReturn>(interval, true);
        interval += interval;
        hasRetryTime ++;

        await nextTimeoutPromise;

        return await retryFunc(arg);
      } else {
        throw err;
      }
    }
  }

  return retryFunc;
}

export default retryPromise;

{"version":3,"file":"store.js","sourceRoot":"","sources":["../src/main/store.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '@sentry/utils';\nimport { dirname, join } from 'path';\n\nimport { Mutex } from '../common/mutex';\nimport { mkdirp, readFileAsync, statAsync, unlinkAsync, writeFileAsync } from './fs';\n\nconst dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.*\\d{0,10}Z$/;\n\n/** JSON revive function to enable de-serialization of Date objects */\nfunction dateReviver(_: string, value: any): any {\n  if (typeof value === 'string' && dateFormat.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n\n/**\n * Stores data serialized to a JSON file.\n */\nexport class Store<T> {\n  /** Current state of the data. */\n  protected _data?: T;\n\n  /** Internal path for JSON file. */\n  private readonly _path: string;\n  /** Value used to initialize data for the first time. */\n  private readonly _initial: T;\n  /** A mutex to ensure that there aren't races while reading and writing files */\n  private _lock: Mutex = new Mutex();\n\n  /**\n   * Creates a new store.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   */\n  public constructor(path: string, id: string, initial: T) {\n    this._path = join(path, `${id}.json`);\n    this._initial = initial;\n  }\n\n  /**\n   * Updates data by replacing it with the given value.\n   * @param data New data to replace the previous one.\n   */\n  public async set(data: T): Promise<void> {\n    await this._lock.runExclusive(async () => {\n      this._data = data;\n\n      try {\n        if (data === undefined) {\n          try {\n            await unlinkAsync(this._path);\n          } catch (_) {\n            //\n          }\n        } else {\n          await mkdirp(dirname(this._path));\n          await writeFileAsync(this._path, JSON.stringify(data));\n        }\n      } catch (e) {\n        logger.warn('Failed to write to store', e);\n        // This usually fails due to anti virus scanners, issues in the file\n        // system, or problems with network drives. We cannot fix or handle this\n        // issue and must resume gracefully. Thus, we have to ignore this error.\n      }\n    });\n  }\n\n  /**\n   * Returns the current data.\n   *\n   * When invoked for the first time, it will try to load previously stored data\n   * from disk. If the file does not exist, the initial value provided to the\n   * constructor is used.\n   */\n  public async get(): Promise<T> {\n    return this._lock.runExclusive(async () => {\n      if (this._data === undefined) {\n        try {\n          this._data = JSON.parse(await readFileAsync(this._path, 'utf8'), dateReviver) as T;\n        } catch (e) {\n          this._data = this._initial;\n        }\n      }\n\n      return this._data;\n    });\n  }\n\n  /**\n   * Updates data by passing it through the given function.\n   * @param fn A function receiving the current data and returning new one.\n   */\n  public async update(fn: (current: T) => T): Promise<void> {\n    await this.set(fn(await this.get()));\n  }\n\n  /** Returns store to its initial state */\n  public async clear(): Promise<void> {\n    await this.set(this._initial);\n  }\n\n  /** Gets the Date that the file was last modified */\n  public async getModifiedDate(): Promise<Date | undefined> {\n    try {\n      return (await statAsync(this._path))?.mtime;\n    } catch (_) {\n      return undefined;\n    }\n  }\n}\n\n/**\n * Extends Store to throttle writes.\n */\nexport class BufferedWriteStore<T> extends Store<T> {\n  /** A write that hasn't been written to disk yet */\n  private _pendingWrite: { data: T; timeout: NodeJS.Timeout } | undefined;\n\n  /**\n   * Creates a new ThrottledStore.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   * @param throttleTime The minimum time between writes\n   */\n  public constructor(path: string, id: string, initial: T, private readonly _throttleTime: number = 500) {\n    super(path, id, initial);\n  }\n\n  /** @inheritdoc */\n  public override async set(data: T): Promise<void> {\n    this._data = data;\n\n    this._pendingWrite = {\n      // We overwrite the data for the pending write so that the latest data is written in the next flush\n      data,\n      // If there is already a pending timeout, we keep that rather than starting the timeout again\n      timeout: this._pendingWrite?.timeout || setTimeout(() => this._writePending(), this._throttleTime),\n    };\n  }\n\n  /** Writes the pending write to disk */\n  private _writePending(): void {\n    if (this._pendingWrite) {\n      const data = this._pendingWrite.data;\n      // Clear the pending write immediately so that subsequent writes can be queued\n      this._pendingWrite = undefined;\n      void super.set(data);\n    }\n  }\n}\n"]}
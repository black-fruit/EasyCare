{"version":3,"file":"sessions.js","sourceRoot":"","sources":["../src/main/sessions.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, makeSession, updateSession } from '@sentry/core';\nimport { flush, NodeClient } from '@sentry/node';\nimport { SerializedSession, Session, SessionContext, SessionStatus } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { sentryCachePath } from './fs';\nimport { Store } from './store';\n\nconst PERSIST_INTERVAL_MS = 60_000;\n\n/** Stores the app session in case of termination due to main process crash or app killed */\nconst sessionStore = new Store<SessionContext | undefined>(sentryCachePath, 'session', undefined);\n\n/** Previous session that did not exit cleanly */\nlet previousSession: Promise<Partial<Session> | undefined> | undefined = sessionStore.get();\n\nlet persistTimer: NodeJS.Timer | undefined;\n\n/** Starts a session */\nexport async function startSession(): Promise<void> {\n  const hub = getCurrentHub();\n  await sessionStore.set(hub.startSession());\n\n  // Every PERSIST_INTERVAL, write the session to disk\n  persistTimer = setInterval(async () => {\n    const currentSession = hub.getScope()?.getSession();\n    // Only bother saving if it hasn't already ended\n    if (currentSession && currentSession.status === 'ok') {\n      await sessionStore.set(currentSession);\n    }\n  }, PERSIST_INTERVAL_MS);\n}\n\n/** Cleanly ends a session */\nexport async function endSession(): Promise<void> {\n  // Once the session had ended there is no point persisting it\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const hub = getCurrentHub();\n  const session = hub.getScope()?.getSession();\n\n  if (session) {\n    if (session.status === 'ok') {\n      logger.log('Ending session');\n      hub.endSession();\n    } else {\n      logger.log('Session was already ended');\n    }\n  } else {\n    logger.log('No session');\n  }\n\n  await sessionStore.clear();\n\n  await flush(2_000);\n}\n\n/** Determines if a Date is likely to have occurred in the previous uncompleted session */\nexport async function unreportedDuringLastSession(crashDate: Date | undefined): Promise<boolean> {\n  if (!crashDate) {\n    return false;\n  }\n\n  const previousSessionModified = await sessionStore.getModifiedDate();\n  // There is no previous session\n  if (previousSessionModified == undefined) {\n    return false;\n  }\n\n  const previousSessionModifiedTime = previousSessionModified.getTime();\n  const crashTime = crashDate.getTime();\n\n  // Session could have run until modified time + persist interval\n  const prevSessionEnd = previousSessionModifiedTime + PERSIST_INTERVAL_MS;\n\n  // Event cannot have occurred before last persist time, We add a 2 second overlap to be sure\n  const lastPersist = previousSessionModifiedTime - 2_000;\n\n  // If the crash occurred between the last persist and estimated end of session\n  return crashTime > lastPersist && crashTime < prevSessionEnd;\n}\n\n/** Checks if the previous session needs sending as crashed or abnormal  */\nexport async function checkPreviousSession(crashed: boolean): Promise<void> {\n  const client = getCurrentHub().getClient<NodeClient>();\n\n  const previous = await previousSession;\n\n  if (previous && client) {\n    // Ignore if the previous session is already ended\n    if (previous.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    const status: SessionStatus = crashed ? 'crashed' : 'abnormal';\n\n    logger.log(`Found previous ${status} session`);\n\n    const sesh = makeSession(previous);\n\n    updateSession(sesh, {\n      status,\n      errors: (sesh.errors || 0) + 1,\n      release: (previous as unknown as SerializedSession).attrs?.release,\n      environment: (previous as unknown as SerializedSession).attrs?.environment,\n    });\n\n    await client.sendSession(sesh);\n\n    previousSession = undefined;\n  }\n}\n\n/** Sets the current session as crashed */\nexport function sessionCrashed(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  logger.log('Session Crashed');\n  const hub = getCurrentHub();\n  const session = hub.getScope()?.getSession();\n\n  if (!session) {\n    logger.log('No session to update');\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as crashed');\n    updateSession(session, { status: 'crashed', errors: (session.errors += 1) });\n  } else {\n    logger.log('Session already ended');\n  }\n\n  hub.captureSession();\n}\n"]}
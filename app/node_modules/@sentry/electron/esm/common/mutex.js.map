{"version":3,"file":"mutex.js","sourceRoot":"","sources":["../../src/common/mutex.ts"],"names":[],"mappings":"AAAA,kFAAkF;AAClF,sDAAsD;AACtD,EAAE;AACF,6DAA6D;AAC7D,oBAAoB;;AA+BpB,gEAAgE;AAChE,MAAM,OAAO,KAAK;IAAlB;QACU,aAAQ,GAAsB,EAAE,CAAC;QACjC,aAAQ,GAAoB,EAAE,CAAC;QAC/B,WAAM,GAAW,CAAC,CAAC;IAgE7B,CAAC;IA9DC,qDAAqD;IACxC,YAAY,CAAI,IAA0B;;YACrD,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAC;YAEtC,IAAI;gBACF,OAAO,MAAM,IAAI,EAAE,CAAC;aACrB;oBAAS;gBACR,OAAO,EAAE,CAAC;aACX;QACH,CAAC;KAAA;IAED,uEAAuE;IAC/D,QAAQ;QACd,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;YAExC,IAAI,CAAC,SAAS,EAAE,CAAC;QACnB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,wCAAwC;IAChC,QAAQ;QACd,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;QACjB,IAAI,CAAC,SAAS,EAAE,CAAC;IACnB,CAAC;IAED,+BAA+B;IACvB,SAAS;;QACf,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,EAAE,EAAE;YACnD,MAAM,UAAU,GAAG,MAAA,IAAI,CAAC,QAAQ,0CAAE,KAAK,EAAE,CAAC;YAC1C,IAAI,CAAC,UAAU;gBAAE,SAAS;YAE1B,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC;YACtB,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAEzB,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;SACzC;QAED,IAAI,CAAC,mBAAmB,EAAE,CAAC;IAC7B,CAAC;IAED,6BAA6B;IACrB,YAAY;QAClB,IAAI,MAAM,GAAG,KAAK,CAAC;QAEnB,OAAO,GAAG,EAAE;YACV,IAAI,MAAM;gBAAE,OAAO;YACnB,MAAM,GAAG,IAAI,CAAC;YAEd,IAAI,CAAC,QAAQ,EAAE,CAAC;QAClB,CAAC,CAAC;IACJ,CAAC;IAED,2BAA2B;IACnB,mBAAmB;QACzB,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,EAAE,EAAE;YACnD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;gBAAE,SAAS;YAEzC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC;YAC5C,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["// This code was originally copied from  https://github.com/DirtyHairy/async-mutex\n// before being significantly simplified for our usage\n//\n// Copied at commit: 3d2d987e60799d0fa222f1df8f99fc90ed570bfd\n// Original licence:\n\n// The MIT License (MIT)\n//\n// Copyright (c) 2016 Christian Speckner <cnspeckn@googlemail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ntype Releaser = () => void;\n\ninterface QueueEntry {\n  resolve(result: Releaser): void;\n  reject(error: unknown): void;\n}\n\n/** An async mutex that queues up tasks for a shared resource */\nexport class Mutex {\n  private _entries: Array<QueueEntry> = [];\n  private _waiters: Array<Releaser> = [];\n  private _value: number = 1;\n\n  /** Run a task when all pending tasks are complete */\n  public async runExclusive<T>(task: () => Promise<T> | T): Promise<T> {\n    const release = await this._acquire();\n\n    try {\n      return await task();\n    } finally {\n      release();\n    }\n  }\n\n  /** Gets a promise that resolves when all pending tasks are complete */\n  private _acquire(): Promise<Releaser> {\n    return new Promise((resolve, reject) => {\n      this._entries.push({ resolve, reject });\n\n      this._dispatch();\n    });\n  }\n\n  /** Releases after a task is complete */\n  private _release(): void {\n    this._value += 1;\n    this._dispatch();\n  }\n\n  /** Dispatches pending tasks */\n  private _dispatch(): void {\n    for (let weight = this._value; weight > 0; weight--) {\n      const queueEntry = this._entries?.shift();\n      if (!queueEntry) continue;\n\n      this._value -= weight;\n      weight = this._value + 1;\n\n      queueEntry.resolve(this._newReleaser());\n    }\n\n    this._drainUnlockWaiters();\n  }\n\n  /** Creates a new releaser */\n  private _newReleaser(): Releaser {\n    let called = false;\n\n    return () => {\n      if (called) return;\n      called = true;\n\n      this._release();\n    };\n  }\n\n  /** Drain unlock waiters */\n  private _drainUnlockWaiters(): void {\n    for (let weight = this._value; weight > 0; weight--) {\n      if (!this._waiters[weight - 1]) continue;\n\n      this._waiters.forEach((waiter) => waiter());\n      this._waiters = [];\n    }\n  }\n}\n"]}